package hmac

import (
	"crypto/subtle"
	"errors"
	"gost_magma_cbc/crypto/hash/streebog"
	"gost_magma_cbc/crypto/models"
)

var (
	ipad = [64]byte{
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	}
	opad = [64]byte{
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	}
)

type HMAC256 struct {
}

func NewHMAC256() models.HMAC {
	return &HMAC256{}
}

func (h *HMAC256) Sum(key []byte, data []byte) ([]byte, error) {
	s := streebog.New256()
	k := [64]byte{}

	if len(key) > 512 {
		return nil, errors.New("unsupported key len")
	}
	zero_count := 64 - len(key)
	for i := 0; i < zero_count; i++ {
		k[i] = 0
	}
	subtle.ConstantTimeCopy(1, k[zero_count:], key)
	k_tmp := [64]byte{}
	subtle.ConstantTimeCopy(1, k_tmp[:], k[:])

	subtle.XORBytes(k_tmp[:], k_tmp[:], ipad[:])
	subtle.XORBytes(k[:], k[:], opad[:])
	data = append(data, k_tmp[:]...)
	sum := s.Sum(data)
	d := [128]byte{}
	subtle.ConstantTimeCopy(1, d[0:64], sum)
	subtle.ConstantTimeCopy(1, d[64:], k[:])
	return s.Sum(d[:]), nil
}

func (h *HMAC256) KeySizeMax() int {
	return 64
}
