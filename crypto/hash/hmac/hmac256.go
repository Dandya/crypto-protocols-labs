package hmac

import (
	"crypto/subtle"
	"errors"
	"gost_magma_cbc/crypto/hash/streebog"
	"gost_magma_cbc/crypto/models"
)

var (
	ipad = [64]byte{
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	}
	opad = [64]byte{
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
		0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	}
)

type HMAC256 struct {
	h models.Hasher
}

func NewHMAC256() models.HMAC {
	return &HMAC256{h: streebog.New256()}
}

func (h *HMAC256) Sum(key []byte, data []byte) ([]byte, error) {
	s := streebog.New256()
	k := [64]byte{}

	if len(key) > 512 {
		return nil, errors.New("unsupported key len")
	}

	zero_count := 64 - len(key)
	subtle.ConstantTimeCopy(1, k[:zero_count], key)
	for i := zero_count; i < 64; i++ {
		k[i] = 0
	}
	k_tmp := make([]byte, 64)
	subtle.ConstantTimeCopy(1, k_tmp[:], k[:])

	subtle.XORBytes(k_tmp[:], k_tmp[:], ipad[:])
	subtle.XORBytes(k[:], k[:], opad[:])
	k_tmp = append(k_tmp, data...)
	s.Write(k_tmp)
	sum := s.Sum(nil)

	s.Reset()
	d := [96]byte{}
	subtle.ConstantTimeCopy(1, d[0:64], k[:])
	subtle.ConstantTimeCopy(1, d[64:], sum)
	s.Write(d[:])
	return s.Sum(nil), nil
}

func (h *HMAC256) KeySizeMax() int {
	return 64
}

func (h *HMAC256) Reset() {
}